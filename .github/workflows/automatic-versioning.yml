name: Automated Versioning

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop 
    # types: [closed]
  workflow_dispatch:

jobs:
  versioning:
    name: Detect Next Version
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necessary to fetch all tags and history for analysis

      - name: Fetch all tags
        id: all_tags
        run: git fetch --depth=1 origin +refs/tags/*:refs/tags/*

      - name: Git Config
        id: git_config
        run: |
            git config --global user.email "${{ github.actor }}@users.noreply.github.com"
            git config --global user.name "${{ github.actor }}"

      - name: Set up initial tag if none exist
        id: initial_tag
        needs: git_config
        run: |
          if [ -z "$(git tag)" ]; then
            git tag v0.0.0
            git push origin v0.0.0
            echo "Set initial version to v0.0.0"
          fi

      - name: Analyze commit messages
        needs: git_config
        id: commits
        run: |
          echo "minor_count=$(git log --format=%B ${{ github.event.before }}..${{ github.event.after }} | grep -c 'feat:')" >> $GITHUB_ENV
          echo "patch_count=$(git log --format=%B ${{ github.event.before }}..${{ github.event.after }} | grep -c 'fix:')" >> $GITHUB_ENV
          echo "breaking_count=$(git log --format=%B ${{ github.event.before }}..${{ github.event.after }} | grep -c 'BREAKING CHANGE:')" >> $GITHUB_ENV

      - name: Fetch PR labels and determine version bump
        needs: all_tags
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        id: label_analysis
        with:
          script: |
            const payload = context.payload.pull_request
            const labels = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: payload.number
            });
            const labelNames = labels.data.map(label => label.name);
            console.log("PR labels:", labelNames);

            // Determine version changes based on labels
            const hasBug = labelNames.includes('bug');
            const hasDocumentation = labelNames.includes('documentation');
            const hasEnhancement = labelNames.includes('enhancement');
            const hasDuplicate = labelNames.includes('duplicate');
            const hasGoodFirstIssue = labelNames.includes('good first issue');
            const hasHelpWanted = labelNames.includes('help wanted');
            const hasInvalid = labelNames.includes('invalid');
            const hasQuestion = labelNames.includes('question');
            const hasWontFix = labelNames.includes('wontfix');

            // Set outputs for later steps
            core.setOutput('patch', hasBug || hasDocumentation || hasDuplicate || hasGoodFirstIssue || hasHelpWanted || hasInvalid || hasQuestion || hasWontFix);
            core.setOutput('minor', hasEnhancement);
            core.setOutput('major', false); // Adjust according to your needs for breaking changes

      - name: Apply version change
        run: |
          if ${{ steps.label_analysis.outputs.major }}; then
            echo "Major version bump required."
          elif ${{ steps.label_analysis.outputs.minor }}; then
            echo "Minor version bump required."
          elif ${{ steps.label_analysis.outputs.patch }}; then
            echo "Patch version bump required."
          else
            echo "No version change required."

      - name: Calculate next version
        run: |
          MAJOR=0
          MINOR=0
          PATCH=0
          LAST_TAG=$(git describe --tags --abbrev=0 --always)
          if [[ $LAST_TAG =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
          fi
          # Logic to increment versions
          if [ "${{ env.breaking_count }}" -gt 0 ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "${{ env.minor_count }}" -gt 0 ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [ "${{ env.patch_count }}" -gt 0 ]; then
            PATCH=$((PATCH + 1))
          fi
          NEW_TAG="v$MAJOR.$MINOR.$PATCH"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV

      - name: Print new version
        run: |
          echo "New Version: $NEW_TAG"

      # Future steps to include source code analysis before finalizing version
